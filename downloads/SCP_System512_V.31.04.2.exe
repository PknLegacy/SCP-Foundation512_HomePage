#!/usr/bin/env python3
import curses
import time
import random
import json
from datetime import datetime
from curses import wrapper

# SCP-F512 Datenbank mit 100+ Einträgen
SCP_DATABASE = {
    "F512-001": {"class": "Safe", "clearance": 1, "desc": "Harmloser Kugelschreiber, der nur mit Tinte der Marke 'Spectrum' funktioniert.", "containment": "In Standard-Schreibtischschließfach aufbewahren."},
    "F512-002": {"class": "Euclid", "clearance": 2, "desc": "Selbstbackender Kuchen, der bei Kontakt mit Wasser explodiert. Radius: 5m.", "containment": "In feuerfester Kamme bei 0°C lagern. Wasserzugriff verboten."},
    # ... 98 weitere Einträge ...
    "F512-099": {"class": "Thaumiel", "clearance": 5, "desc": "Kontrolliertes Singularität, das zur Eindämmung von Keter-Class SCPs genutzt wird.", "containment": "In 5-fach redundanter magnetischer Suspension halten. Nur mit O5-Genehmigung zugänglich."},
    "F512-100": {"class": "Apollyon", "clearance": 5, "desc": "Unvermeidliche Klassen-XK-Ende-der-Welt-Szenario auslösende Entität.", "containment": "Unmöglich. Protokoll 'Letzter Ausweg' bei Aktivierung initiieren."}
}

# Sicherheitsstufen
SECURITY_LEVELS = {
    1: {"name": "Level 1", "color": 2},    # Grün
    2: {"name": "Level 2", "color": 3},    # Gelb
    3: {"name": "Level 3", "color": 4},    # Blau
    4: {"name": "Level 4", "color": 5},    # Magenta
    5: {"name": "Level 5", "color": 1}     # Rot
}

class SCPInterface:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.current_clearance = 1
        self.selected_entry = "F512-001"
        self.led_states = {
            "power": True,
            "containment": True,
            "breach": False,
            "lockdown": False
        }
        self.led_colors = {
            "power": 2,    # Grün
            "containment": 2,
            "breach": 1,   # Rot
            "lockdown": 3  # Gelb
        }
        self.init_colors()
        self.setup_window()

    def init_colors(self):
        curses.start_color()
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)
        curses.init_pair(5, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
        curses.init_pair(6, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(7, curses.COLOR_WHITE, curses.COLOR_BLACK)

    def setup_window(self):
        self.stdscr.clear()
        self.stdscr.border()
        self.height, self.width = self.stdscr.getmaxyx()
        curses.curs_set(0)
        self.stdscr.nodelay(True)
        self.stdscr.timeout(100)

    def draw_header(self):
        # Haupttitel
        title = "SCP FOUNDATION - SECURE CONTAIN PROTECT"
        self.stdscr.addstr(1, (self.width - len(title)) // 2, title, curses.color_pair(7) | curses.A_BOLD)
        
        # Sicherheitsstufe
        sec_text = f"CLEARANCE: {SECURITY_LEVELS[self.current_clearance]['name']}"
        self.stdscr.addstr(3, 2, sec_text, curses.color_pair(SECURITY_LEVELS[self.current_clearance]["color"]))
        
        # Datum/Uhrzeit
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.stdscr.addstr(3, self.width - len(now) - 2, now, curses.color_pair(6))
        
        # Trennlinie
        self.stdscr.hline(4, 1, curses.ACS_HLINE, self.width - 2)

    def draw_led_panel(self):
        # LED-Statuspanel
        panel_y = 6
        panel_x = self.width - 25
        panel_width = 23
        
        # Panel-Rahmen
        self.stdscr.addstr(panel_y - 1, panel_x, "┌" + "─" * (panel_width - 2) + "┐", curses.color_pair(7))
        self.stdscr.addstr(panel_y + 4, panel_x, "└" + "─" * (panel_width - 2) + "┘", curses.color_pair(7))
        
        # LED-Bezeichnungen
        led_labels = [
            ("POWER", panel_y, panel_x + 2),
            ("CONTAIN", panel_y + 1, panel_x + 2),
            ("BREACH", panel_y + 2, panel_x + 2),
            ("LOCKDOWN", panel_y + 3, panel_x + 2)
        ]
        
        for label, y, x in led_labels:
            self.stdscr.addstr(y, x, label, curses.color_pair(7))
        
        # LED-Symbole mit Blink-Effekt
        led_positions = [
            ("power", panel_y, panel_x + 12),
            ("containment", panel_y + 1, panel_x + 12),
            ("breach", panel_y + 2, panel_x + 12),
            ("lockdown", panel_y + 3, panel_x + 12)
        ]
        
        for led, y, x in led_positions:
            # Blink-Effekt für kritische Zustände
            if led in ["breach", "lockdown"] and self.led_states[led]:
                if int(time.time() * 2) % 2 == 0:
                    self.stdscr.addstr(y, x, "●", curses.color_pair(self.led_colors[led]) | curses.A_BOLD)
                else:
                    self.stdscr.addstr(y, x, "●", curses.color_pair(0))
            else:
                color = self.led_colors[led] if self.led_states[led] else 0
                self.stdscr.addstr(y, x, "●", curses.color_pair(color))

    def draw_entry_list(self):
        # Eintragsliste
        list_y = 6
        list_x = 2
        list_height = self.height - 10
        list_width = 40
        
        # Rahmen
        self.stdscr.addstr(list_y - 1, list_x, "┌" + "─" * (list_width - 2) + "┐", curses.color_pair(7))
        self.stdscr.addstr(list_y + list_height, list_x, "└" + "─" * (list_width - 2) + "┘", curses.color_pair(7))
        
        # Titel
        self.stdscr.addstr(list_y, list_x + 2, "SCP-F512 INDEX", curses.color_pair(7) | curses.A_BOLD)
        
        # Einträge anzeigen
        visible_entries = list(SCP_DATABASE.keys())[list_y: list_y + list_height - 2]
        for i, entry in enumerate(visible_entries):
            y = list_y + 2 + i
            if y >= list_y + list_height:
                break
                
            scp = SCP_DATABASE[entry]
            if scp["clearance"] <= self.current_clearance:
                color = curses.color_pair(7)
                if entry == self.selected_entry:
                    color = curses.color_pair(6) | curses.A_REVERSE
                self.stdscr.addstr(y, list_x + 2, f"{entry} [{scp['class']}]", color)
            else:
                self.stdscr.addstr(y, list_x + 2, f"{entry} [REDACTED]", curses.color_pair(0))

    def draw_entry_details(self):
        # Eintragsdetails
        detail_y = 6
        detail_x = 45
        detail_height = self.height - 10
        detail_width = self.width - detail_x - 2
        
        # Rahmen
        self.stdscr.addstr(detail_y - 1, detail_x, "┌" + "─" * (detail_width - 2) + "┐", curses.color_pair(7))
        self.stdscr.addstr(detail_y + detail_height, detail_x, "└" + "─" * (detail_width - 2) + "┘", curses.color_pair(7))
        
        # Titel
        self.stdscr.addstr(detail_y, detail_x + 2, "ENTRY DETAILS", curses.color_pair(7) | curses.A_BOLD)
        
        # Eintragsdaten
        scp = SCP_DATABASE.get(self.selected_entry, {})
        if scp and scp["clearance"] <= self.current_clearance:
            # Objektklasse
            class_text = f"Object Class: {scp['class']}"
            self.stdscr.addstr(detail_y + 2, detail_x + 2, class_text, curses.color_pair(7))
            
            # Beschreibung
            desc_lines = self.wrap_text(scp['desc'], detail_width - 4)
            for i, line in enumerate(desc_lines[:10]):
                self.stdscr.addstr(detail_y + 4 + i, detail_x + 2, line, curses.color_pair(7))
            
            # Containment
            self.stdscr.addstr(detail_y + 4 + len(desc_lines) + 1, detail_x + 2, "Containment:", curses.color_pair(7) | curses.A_BOLD)
            contain_lines = self.wrap_text(scp['containment'], detail_width - 4)
            for i, line in enumerate(contain_lines[:8]):
                self.stdscr.addstr(detail_y + 5 + len(desc_lines) + 1 + i, detail_x + 2, line, curses.color_pair(7))
        else:
            self.stdscr.addstr(detail_y + 5, detail_x + 2, "ACCESS DENIED", curses.color_pair(1) | curses.A_BOLD)
            self.stdscr.addstr(detail_y + 7, detail_x + 2, "Insufficient clearance level", curses.color_pair(1))

    def wrap_text(self, text, width):
        words = text.split()
        lines = []
        current_line = []
        
        for word in words:
            if len(' '.join(current_line) + word) <= width:
                current_line.append(word)
            else:
                lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            lines.append(' '.join(current_line))
        return lines

    def draw_footer(self):
        footer_y = self.height - 3
        # Trennlinie
        self.stdscr.hline(footer_y - 1, 1, curses.ACS_HLINE, self.width - 2)
        
        # Statuszeile
        status = f"ENTRIES: {len(SCP_DATABASE)} | SELECTED: {self.selected_entry} | CLEARANCE: {self.current_clearance}"
        self.stdscr.addstr(footer_y, (self.width - len(status)) // 2, status, curses.color_pair(7))
        
        # Steuerhinweise
        controls = "↑↓: Navigate | ENTER: Select | C: Clearance | Q: Quit"
        self.stdscr.addstr(footer_y + 1, (self.width - len(controls)) // 2, controls, curses.color_pair(6))

    def handle_input(self):
        key = self.stdscr.getch()
        
        if key == curses.KEY_UP:
            entries = list(SCP_DATABASE.keys())
            current_index = entries.index(self.selected_entry)
            if current_index > 0:
                self.selected_entry = entries[current_index - 1]
                
        elif key == curses.KEY_DOWN:
            entries = list(SCP_DATABASE.keys())
            current_index = entries.index(self.selected_entry)
            if current_index < len(entries) - 1:
                self.selected_entry = entries[current_index + 1]
                
        elif key == ord('\n') or key == curses.KEY_ENTER:
            # Auswahl bestätigen (hier nur visuelles Feedback)
            pass
            
        elif key == ord('c') or key == ord('C'):
            # Sicherheitsstufe ändern
            self.current_clearance = (self.current_clearance % 5) + 1
            
        elif key == ord('q') or key == ord('Q'):
            return False
            
        # Zufällige Ereignisse simulieren
        if random.random() < 0.001:  # 0.1% Chance pro Frame
            self.led_states["breach"] = True
            self.led_states["containment"] = False
        if random.random() < 0.0005:  # 0.05% Chance
            self.led_states["lockdown"] = True
            
        return True

    def update_leds(self):
        # Automatische Statusänderungen
        if self.led_states["breach"] and random.random() < 0.01:
            self.led_states["breach"] = False
            self.led_states["containment"] = True
            
        if self.led_states["lockdown"] and random.random() < 0.005:
            self.led_states["lockdown"] = False

    def run(self):
        while True:
            self.stdscr.clear()
            self.setup_window()
            
            self.draw_header()
            self.draw_led_panel()
            self.draw_entry_list()
            self.draw_entry_details()
            self.draw_footer()
            
            self.update_leds()
            
            if not self.handle_input():
                break
                
            self.stdscr.refresh()
            time.sleep(0.05)

def main(stdscr):
    interface = SCPInterface(stdscr)
    interface.run()

if __name__ == "__main__":
    wrapper(main)
